---
title: "midterm"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

###Data Cleaning
```{r cars}
library(dplyr)

df = read.csv("cars.csv", header = T, stringsAsFactors = TRUE)

df = subset(df, select=c("manufacturer_name", "model_name", "transmission", "color", "odometer_value", "year_produced", "engine_fuel", "engine_has_gas", "engine_type", "engine_capacity", "body_type", "has_warranty",
"state", "drivetrain", "price_usd", "is_exchangeable", "number_of_photos",  "up_counter"))
names(df)[names(df) == 'price_usd'] <- 'price'

```


```{r}
names(df)[names(df) == 'price_usd'] <- 'price'
```


Checking for the the facors and numerical features   
```{r}
str(df)
```
Looks perfectly fine

###Check for nulls
```{r}

colSums(is.na(df))

```
#Enigine Capicity has 10 null values
```{r}
#Droping the rows with null values 
df <- df[complete.cases(df), ]
```

##Target valrible distribution
```{r}
library(ggplot2)
#p <-  ggplot(df, aes(price_usd)) 
#p + geom_boxplot()
p + geom_density()
#df %>%  ggplot( aes(x=manufacturer_name, y=price_usd)) +   geom_boxplot(outlier.colour="red", #outlier.shape=8,outlier.size=4)
#p + geom_point(x='price_usd',y='manufacturer_name')
```

We can observe that the target variable is nor normally distributed which is an assumption of the linear regression model
Let try the box-Cox transformation to normalize the target variable

```{r}
library(MASS)
y = df$price
df %>% ggplot(aes(price)) + geom_density()

result = boxcox(y~1)
#Getting the optimal lambda value
mylambda = result$x[which.max(result$y)]
mylambda
#Transforming the price to new feature using the lambda value
# To get the original price, perform inverse operation to the one below
price_normal = (y^mylambda-1)/mylambda
data_frame(val=y2) %>% ggplot(aes(val)) + geom_density()

df <- cbind(df,price_normal)
```

```{r}
#library("corrplot")
#dfcorr <- cor(df)
#corrplot.mixed(dfcorr)

library(corrplot)
library(tidyverse)

df %>% select_if(is.numeric)->cars_numerical

corrplot(cor(cars_numerical), method = 'number')


```




## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}

boxplot(df['manufacturer_name'], df['price_usd'])
car_lm = lm(price_usd ~ ., data = df2)


library(s20x)
pairs20x(df2)
```
```{r}
library(ezids)
loadPkg("corrplot")
corrplot(df2)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r}
#loadPkg("leaps")
reg.best10 <- leaps::regsubsets(price_usd~. , data = df, nvmax = 10, nbest = 1, method = "exhaustive")  

# leaps::regsubsets() - Model selection by exhaustive (default) search, forward or backward stepwise, or sequential replacement
#The plot will show the Adjust R^2 when using the variables across the bottom
plot(reg.best10, scale = "adjr2", main = "Adjusted R^2")
plot(reg.best10, scale = "r2", main = "R^2")
# In the "leaps" package, we can use scale=c("bic","Cp","adjr2","r2")
plot(reg.best10, scale = "bic", main = "BIC")
plot(reg.best10, scale = "Cp", main = "Cp")
summary(reg.best10)
```


